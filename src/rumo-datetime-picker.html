<link rel="import" href="../../polymer/polymer-element.html">

<link rel="import" href="../../vaadin-icons/vaadin-icons.html">
<link rel="import" href="../../vaadin-ordered-layout/vaadin-vertical-layout.html"> 
<link rel="import" href="../../vaadin-date-picker/vaadin-date-picker.html">
<link rel="import" href="../../vaadin-text-field/vaadin-text-field.html">

<link rel="import" href="../../vaadin-lumo-styles/color.html">
<link rel="import" href="../../vaadin-lumo-styles/sizing.html">
<link rel="import" href="../../vaadin-lumo-styles/spacing.html">
<link rel="import" href="../../vaadin-lumo-styles/style.html">
<link rel="import" href="../../vaadin-lumo-styles/typography.html">

<script src="../../sugar/dist/sugar.min.js"></script>
<script src="../../sugar/dist/locales/de.js"></script>

<dom-module id="rumo-datetime-picker">
  <template>
    <style include="lumo-color lumo-typography">/* empty */</style>
    <div class="container">
      <vaadin-vertical-layout theme="padding">
        <label class="block">[[label]]</label>
        <div class="block">
          <vaadin-date-picker
            id="date"
            max="[[_maxDate]]"
            min="[[_minDate]]"
            value="{{date}}"
            error-message="Please enter a valid date"></vaadin-date-picker>
        </div>
        <div class="block">
          <vaadin-text-field
            id="time"
            value="{{time}}"
            pattern="^([01]?[0-9]|2[0-3]):[0-5][0-9]$"
            error-message="Please enter a valid time">
            <iron-icon icon="vaadin:clock" slot="suffix"></iron-icon>
          </vaadin-text-field>
        </div>
      </vaadin-vertical-layout>
    </div>
  </template>
  <script>
    /**
     * `rumo-datetime-picker`
     * rumo-datetime-picker is a Web Component providing a date and time selection field.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class RumoDatetimePicker extends Polymer.Element {
      static get is() {
        return 'rumo-datetime-picker';
      }
      static get properties() {
        return {
          date: {
            type: String,
            value: Sugar.Date.format(new Date(), '%Y-%m-%d'),
          },
          dateTime: {
            type: Object,
            computed: '_computeDateTime(date, time)',
          },
          label: {
            type: String,
            value: '',
            observer: '_labelChanged',
          },
          max: {
            type: String,
            observer: '_maxChanged',
            reflectToAttribute: true,
          },
          min: {
            type: String,
            observer: '_minChanged',
            reflectToAttribute: true,
          },
          time: {
            type: String,
            value: '00:00',
          },
        };
      }

      constructor() {
        super();

        Sugar.extend();
      }

      ready() {
        super.ready();

        Sugar.Date.setLocale('de');
        this._i18nCalendar(this.$.date);

        if (
          (this.min != null && this.min !== '') ||
          (this.max != null && this.max !== '')
        ) {
          this.$.time.addEventListener('blur', this._timeChanged.bind(this));
        }
      }

      _computeDateTime(date, time) {
        if (!!date && !!time) {
          const [hours, minutes] = time.split(':');
          const dateTime = Sugar.Date.create(date)
            .addHours(hours)
            .addMinutes(minutes);

          return dateTime;
        }
      }

      _labelChanged(label) {
        if (label !== '' && label != null) {
          this.setAttribute('has-label', '');
        } else {
          this.removeAttribute('has-label');
        }
      }

      _handleDateChange(property, value, oldValue) {
        if (!value) {
          this[property] = '';
          return;
        }

        const isDate = Object.prototype.toString.call(value) === '[object Date]';

        if (isDate) {
          this._updateDateTime(property, value);
          this[property] = Sugar.Date.format(value, '%Y-%m-%d');
        } else {
          this[property] = oldValue ? Sugar.Date.format(oldValue, '%Y-%m-%d') : '';
        }
      }

      _updateDateTime(property, value) {
        const dateTime = Sugar.Date.create(this.dateTime);
        const dtDate = Sugar.Date.format(dateTime, '%Y-%m-%d');
        const dtTime = Sugar.Date.format(dateTime, '%H:%M');
        const [dtHours, dtMinutes] = dtTime.split(':');
        const dateTimeBOD = Sugar.Date.create(`${dtDate} 00:00:00`);

        const date = Sugar.Date.create(value);
        const dDate = Sugar.Date.format(date, '%Y-%m-%d');
        const dTime = Sugar.Date.format(date, '%H:%M');
        const dateBOD = Sugar.Date.create(`${dDate} 00:00:00`);

        if (property === '_maxDate') {
          const temp = dateBOD.addHours(dtHours).addMinutes(dtMinutes);

          if (dateTimeBOD.isAfter(dateBOD)) {
            this.date = dDate;
          }

          if (temp.isAfter(date)) {
            this.time = dTime;
          }
        }

        if (property === '_minDate') {
          const temp = dateBOD.addHours(dtHours).addMinutes(dtMinutes);

          if (dateTimeBOD.isBefore(dateBOD)) {
            this.date = dDate;
          }

          if (temp.isBefore(date)) {
            this.time = dTime;
          }
        }
      }

      _maxChanged(value, oldValue) {
        this._handleDateChange('_maxDate', value, oldValue);
      }

      _minChanged(value, oldValue) {
        this._handleDateChange('_minDate', value, oldValue);
      }

      _timeChanged() {
        if (this.max != null && this.max !== '') {
          this._updateDateTime('_maxDate', this.max);
        }

        if (this.min != null && this.min !== '') {
          this._updateDateTime('_minDate', this.min);
        }
      }

      _i18nCalendar(calendar) {
        calendar.i18n = {
          week: 'Woche',
          calendar: 'Kalender',
          clear: 'Leeren',
          today: 'Heute',
          cancel: 'Abbrechen',
          firstDayOfWeek: 1,
          monthNames: 'Januar_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_',
          ),
          weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
            '_',
          ),
          weekdaysShort: 'so_mo_di_mi_do_fr_sa'.split('_'),
          formatDate(date) {
            return Sugar.Date.format(Sugar.Date.create(date), '{short}');
          },
          formatTitle(monthName, fullYear) {
            return `${monthName} ${fullYear}`;
          },
          parseDate(dateString) {
            const date = Sugar.Date.create(dateString);
            return {
              day: date.getDate(),
              month: date.getMonth(),
              year: date.getFullYear(),
            };
          },
        };
      }
    }

    window.customElements.define(RumoDatetimePicker.is, RumoDatetimePicker);
  </script>
</dom-module>
